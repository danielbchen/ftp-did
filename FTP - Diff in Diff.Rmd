---
title: "Florida's Family Transition Program - A Difference-in-Differences Analysis"
author: "Daniel Chen"
date: "3/26/2021"
output: html_document
---

```{r setup, include=FALSE}
library(foreign)
library(kableExtra) 
library(purrr)
library(tidyverse)
library(gridExtra)
library(broom)
library(car)
library(lmtest)
library(plm)
library(lfe)
library(estimatr)
library(stargazer)

setwd(paste("/Users/danielchen/Desktop",
            "/UChicago/Year Two/Autumn 2020/Program Evaluation/",
            "Problem Sets/Problem Set 4/", sep=""))

ftp <- read.dta("ftp_ar.dta")
ftp_srv <- read.dta("ftp_srv.dta")
```

#### The goal of this project is to analyze the effect of Florida's Family Transition Program on economic outcomes such as employment and welfare receipt. I will use a difference-in-differences approach. For this project, the treatment variable will not be the original assignment variable, but it will instead be whether or not an individual *believed* that their benefits were time limited.


To start, I need to find the quarterly employment for each of the 10 quarters prior to random assignment along with the 19 quarters that follow it. I do this to determine the longest pre-preiod and post-period sample to be analyzed, as I'll drop quarters containing any missing values. 

```{r Employment Means Setup, include=FALSE}
# Select all the pre_ra employment variables from the ftp_ar data only
employment_vars_pre_ra <- ftp %>%
  select(matches("emppq"))

# Calculate the means 
pre_ra_means <- colMeans(employment_vars_pre_ra, na.rm = TRUE)

# Create vector containing the quarter of random assignment 
exclude <- c("empq1")

# Select all the post_ra employment variables except for the quarter of assignment
employment_vars_post_ra <- ftp %>%
  select(starts_with("empq"), -one_of(exclude))

# Add back in the quarter of random assignment so we can check if there are any NA values 
employment_vars_post_ra_with_ra <- ftp %>%
  select(starts_with("empq"))

# Calculate means
post_ra_means <- colMeans(employment_vars_post_ra, na.rm = TRUE)

# Check columns for NA values in the pre_ra variables 
pre_ra_na_check <- colSums(is.na(employment_vars_pre_ra))

# Check columns for NA values in the post_ra variables
post_ra_na_check <- colSums(is.na(employment_vars_post_ra_with_ra))
```

```{r Employment Means Output, echo=FALSE}
# Print out pre-ra means in a table
t(pre_ra_means) %>% 
  kable(caption = "Means for Pre-RA Employment Variables",
        "html") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)

# Print out post-ra means in a table
post_ra_means %>% 
  kable(col.names = c("Mean"), 
        caption = "Means for Post-RA Employment Variables",
        "html") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)

# Print out table showing number of NA values in each pre-ra employment variable
t(pre_ra_na_check ) %>% 
  kable(caption = "Num. of NA Values in Pre-RA Employment Variables",
        "html") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)

# Print out table showing number of NA values in each post-ra employment variable
post_ra_na_check  %>% 
  kable(col.names = c("# of NAs"),
        caption = "Num. of NA Values in Post-RA Employment Variables",
        "html") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)
```

From the tables above the longest pre-period that I can analyze is 9 periods from `empqq1` to `emppq9` inclusive. The longest post-period that I can analyze is 17 periods from `empq1` to `empq17` inclusive as none of these contain NA values. `emppq10`, `empq18`, `empq19`, and `empq20` contain NA values.

Next I reshape our data from wide to long and calculate the mean employment rate by treatment status before and after treatment. I consider the period of random assignment itself to be in the after period. 

```{r Means by Treatment Status Before and After Treatment Setup, include=FALSE}
# Merge the two datasets 
merged_data <- ftp %>%
  inner_join(ftp_srv, by="sampleid") %>%
  rename_at(vars(ends_with(".x")), funs(str_replace(., "\\..$",""))) %>%
  select(-ends_with(".y"))

# Create the TLyes treatment indicator dummy
merged_data <- merged_data %>%
  filter(!is.na(fmi2)) %>%
  filter(fmi2 != 8) %>%
  mutate(TLyes = ifelse(fmi2 == 1, 1, 0))

# Create a vector containing the names of variables needed to reshape the data 
vars <- c("sampleid",
          "TLyes",
          names(employment_vars_pre_ra), 
          "empq1", # Add back in the quarter of RA
          names(employment_vars_post_ra)) # Remove cols with NA

# Calculate employment rates by treatment status before and after treatment.
employment_rate_matrix <- merged_data %>% 
  select(vars) %>% # Subset data to only include variables of interest 
  gather(Quarter, Employed, -sampleid, -TLyes) %>% # Reshapes data from wide to long
  mutate(post_treatment = case_when(Quarter %in% names(employment_vars_pre_ra) ~ 0, # Create post_treatment dummy indicator
                                    Quarter %in% names(employment_vars_post_ra) | Quarter == 'empq1' ~ 1)) %>% 
  group_by(TLyes, post_treatment) %>%
  summarize(Employment_Rate = mean(Employed, na.rm = TRUE)) # Calculate employment matrix

# Regress Employment Outcomes on the treatment variable only in the pre-treatment period
employment_rate_test <- merged_data %>% 
  select(vars) %>% # Subset data to only include variables of interest 
  gather(Quarter, Employed, -sampleid, -TLyes) %>% # Reshapes data from wide to long
  mutate(post_treatment = case_when(Quarter %in% names(employment_vars_pre_ra) ~ 0, # Create post_treatment dummy indicator
                                    Quarter %in% names(employment_vars_post_ra) | Quarter == 'empq1' ~ 1)) %>%
  filter(post_treatment == 0) %>%
  lm(Employed ~ TLyes, data =.)

# T-Test for difference in means 
ttest <- merged_data %>% 
  select(vars) %>% # Subset data to only include variables of interest 
  gather(Quarter, Employed, -sampleid, -TLyes) %>% # Reshapes data from wide to long
  mutate(post_treatment = case_when(Quarter %in% names(employment_vars_pre_ra) ~ 0, # Create post_treatment dummy indicator
                                    Quarter %in% names(employment_vars_post_ra) | Quarter == 'empq1' ~ 1)) %>%
  filter(post_treatment == 0) %>%
  t.test(Employed ~ TLyes, data = .)
```

```{r Employment Rate Matrix and t-Test Output, echo=FALSE}
employment_rate_matrix %>% 
  kable(caption = "Employment Rate by Treatment Group and Period",
        'html') %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)

tidy(employment_rate_test) %>%
  kable(caption = "Employment Rate Explained by Treatment Status in pre-ra Period",
        'html') %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)

tidy(ttest) %>%
  kable(caption = "Welch's Two Sample t-test Comparing Employment Rate in by Treatment Status in pre-ra Period",
        'html') %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)
```


In looking just at the employment rate table, the average employment for the control group prior to treatment (`TLyes` = 0 and `post_treat` = 0) was roughly 19% compared to the treatment group prior to treatment (`TLyes` = 1 and `post_treat` = 0) which was roughly 21%. They appear to be fairly close, but when I regress employment outcomes on `TLyes` restricting the sample only to the pre-treatment period, the p-value for the coefficient on `TLyes` is 0.0172577, suggesting a statistically significant difference between the employment rate in the pre-random assignment period between those who believe in the time limit and those who do not. I also ran Welch's Two Sample t-test explicitly and the test also confirms a meaningful difference in means with a p-value of .0161 and t-stat of -2.4072.

Next I run a difference-in-differences regression where the dependent variable is employment status, and the explanatory variables are the person dummies, quarter dummies, and an interaction between `TLyes` and a post-treatment dummy. I ignore the quarters containing NA values that I identified earlier. 

```{r OLS DiD Setup, include=FALSE}
# Store the names of the variables containing NA values into its own object 
na_cols <- c("emppq10", "empq18", "empq19", "empq20")

# Store the long dataframe into its own object and filter out the variables that contain NA values 
merged_data_long <- merged_data %>% 
  select(vars) %>% # Subset data to only include variables of interest 
  gather(Quarter, Employed, -sampleid, -TLyes) %>% # Reshapes data from wide to long
  mutate(post_treatment = case_when(Quarter %in% names(employment_vars_pre_ra) ~ 0, # Create post_treatment dummy indicator
                                    Quarter %in% names(employment_vars_post_ra) | Quarter == 'empq1' ~ 1)) %>%
  filter(!Quarter %in% na_cols)

# Run regression
ols <- lm(Employed ~ as.factor(sampleid) + as.factor(Quarter) + TLyes*post_treatment, data =  merged_data_long)
#model <- plm(Employed ~ sampleid + Quarter + TLyes*post_treatment, data = merged_data_long, index = c("sampleid", "Quarter"), model = "within")
#summary(model)

# Filter to only show the interaction term 
ols_output <- tidy(ols) %>%
  filter(term == "TLyes:post_treatment")
```

```{r Question 3a OLS DiD Output, echo=FALSE}
ols_output %>% 
  kable(caption = "Diff-in-Diff OLS Model",
        "html") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)
```

I run the same regression this time clustering the standard errores by `sampleid` because autocorrelation tends to be a problem for panel studies. While R provides multiple libraries to work with panel models, for this project I use the `plm` library. 

```{r Clustered OLS DiD Setup, include=FALSE, message=FALSE}
# Create the interaction term as its own variable 
merged_data_long$TLyes_post_treatment <- merged_data_long$TLyes * merged_data_long$post_treatment

# Run model using plm function and coeftest to get correct standard errors
clustered_plm <- plm(Employed ~ sampleid + Quarter + TLyes*post_treatment, 
                     data = merged_data_long, 
                     index = c("sampleid", "Quarter"), 
                     model = "within")
clustered_plm_output <- coeftest(clustered_plm, vcovHC(clustered_plm, type = "HC1", cluster = "group"))

clustered_plm_df <- tidy(clustered_plm_output) %>% 
  filter(term == "TLyes:post_treatment")
```

```{r Clustered OLS DiD Output, echo=FALSE}
# Print clustered output as a table
clustered_plm_df %>% 
  kable(caption = "Diff-in-Diff Clustered by sampleid Using plm()",
        "html") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)
```

The standard error of the interaction term increases from 0.01064142 (OLS without clustering) to roughly 0.01999 (clustered by `sampleid`). The standard error increases because clustering addresses time dependence. Observations at different times might not be independent. Because standard OLS doesn't account for this, we will overstate/overestimate the signficance of our results by (falsely) assuming greater precision in our estimates. 